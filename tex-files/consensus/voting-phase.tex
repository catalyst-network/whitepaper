The third phase of the ledger cycle is the Voting phase. In this phase, the producer $p$ collects the $c$ values broadcast by the other producers. By this stage of the consensus algorithm, the only producers that remain should be those that have $h^{maj}$. These recieved $c$ values are incorporated into a set $C$. This set $C$ is used by the producers to determine the complete list of producers that gave the correct update and thereby those that should be rewarded for their contribution. $C_{min}$ is the minimum number of retrieved votes that a producer can have in order to give a valid final update, thereby the producer $p$ continues collecting broadcast votes $c$ until $C \geq C_{min}$. \\


Upon retrieving enough $c$ values from other producers to meet the threshold $C_{min}$, $p$ must again attempt to decode the $u^{maj}$ values contained within its set $C$. This is done as in the campaigning phase. The amount of decoded values must meet the threshold determined by:  

\begin{center} 
$C_{threshold}(99.999\%) = \left( 0.5 + 4.22\sqrt{\frac{C^{dec}(C-C^{dec})}{C}}\right) \times C$
\end{center} 

Where $C^{dec}$ is the number of values that $p$ was capable of decoding. If this threshold is met then it can be assumed that with a 99.999\% certainty that a majority of the $C$ values collected by $p$ were in fact the correct update. In reality this number should be significantly higher if not 100\% due to only the producers who hold the correct update having reached this stage of the consensus algorithm. \\

Upon confirming that $p$ is in the majority, they can now begin to produce the final list of producers that created the correct ledger state update. They, take the $C^{dec}$ subset and extract the bloom filters attached to that set. $p$ also retrieves the list of producers for that specific cycle from the DAO. For each element in the list of producers their membership is checked in each of the bloom filters in $C^{dec}$. If an element from that list appears in more that half of the bloom filters that element is added to a new list $\mathcal{L}_{final}$, upon checking all the elements from the list of producers against the retrieved bloom filters a new bloom filter is created $\#(\mathcal{L}_{final})$ containing all elements determined to have been present in more than half of the bloom filters. 




\begin{comment}

The third phase of the ledger cycle is the Voting Phase within which a producer $p$ from the $C$ candidates it has received confirms what it believes should be the global ledger state update \textit{i.e.} the update that should be applied to the ledger for that cycle. Furthermore it also decides on the combined list of producers that it believed also reached produced the same update. \\

$p$ begins by waiting to retrieve $C_{min}$ $c$ values from other producers. At this stage the only producers that reach this stage of the consensus algorithm should be those who have produced the majority ledger state update, however as with the campaigning phase the user attempts to decode the $h^{maj}$ value that is contained within each $c$. This will be according to the threshold:\\
 


To determine the minimum number of decoded $C$ values $p$ can accept above 50\% to guarantee with a 99.999\% probability that they have indeed found a majority. \\

Any PId that were not in $p$'s $\#(\mathcal{L})$ should now be added to the hash tree $\#(\mathcal{L}_{final})$. 


\begin{enumerate}
\item $p$ verifies that the same first hash value $u^{maj}$ is embedded in a majority of producer candidates.
\item $p$ is required at this point to have created the majority ledger update. As only with this partial update can they participate effectively. Therefore their $u == u^{maj}$
\end{enumerate}

If each producer collects the first hash value generated by every producer, any two producers would build the same list of identifiers $\mathcal{L}(prod)$. However even in highly efficient distributed network it is unlikely that all producers will retrieve all information. Therefore it must be assumed that the list of identifiers held by $p$ is incomplete, $p$ however must ensure that they hold enough information to confidently issue a vote on the update to the ledger. The identifier of a producer is appended to the hash they distribute because:

\begin{itemize}
\item To verify that $p$ is a producer node and that they in fact were one of the winners of the random draw described in \ref{insert ref}.
\item To evaluate and track the quality of the work performed by $p$.
\item To ensure that the correct producers withing $P$ are rewarded for their work maintaining the ledger. \\

\end{itemize}

New transaction entries (compensation entries) are created using the list's  $\mathcal{L}(prod)$ produced by the producers $p$. This allows reward and fees to be paid to the correct users. These new transaction entries will be appended to the final ledger state update for that cycle. Therefore a complete ledger state update should consist of:

\begin{itemize}
\item The list of transaction entries integrated into the new ledger state all $E$ lists.
\item The transaction signatures from $T$ held in $d$.
\item Compensation entries rewarding the producers from $\mathcal{L}(prod)$.

\end{itemize}

The voting process thereby must confirm the correct list of identifiers involved in producing the correct ledger state updates. The final list for  $\mathcal{L}(prod)$ is generated by merging the producers lists together. In order for a producer $p$ to have their $Id$ added to the final  $\mathcal{L}(prod)$ the must appear in at least 50\% of the  $\mathcal{L}(prod)$ lists distributed by $P$. This ensures that no producer can just append their own $Id$ to their update whether that update was correct or not and gain a reward for it.  \\

This process ensures that only producers that have provided the correct update may receive this part of the reward, thereby preventing unethical behavior from producers by declaring that they got the correct update when in fact they did not. However, it does introduce the problem of producers that have created the wrong ledger update being disincentiveise from proceeding in the consensus process further. Therefore producers that vote for the correct update whether or not they produced the correct update should also receive a portion of the reward. This is determined by the list $\mathcal{L}(vote)$ that each $p$ creates to store the Id's of the producers which the gained votes from that voted for the correct update.

$p$ follows a series of steps:

\begin{enumerate}
\item $p$ generates a list $\mathcal{L}(vote)$ it then appends the $Id$ of any other $p$ that has forwarded a $C$ candidate that satisfies $u == u^{maj}$.
\item $p$ creates the combined list for $\mathcal{L}(prod)$ of any $p$ from $P$ that appears in $P/2$ lists.
\item Then $p$ creates a list $L_{CE}$. This contains the contribution entries. This is for any user that is included in the combined $\mathcal{L}(prod)$. Each of these producers contained within this list will receive $x$ tokens. If it is considered that $X$ is the total number of tokens that are injected into the network at each cycle for the pool of $P$ producers. The amount of entries into $L_{CE}$ will be less than or equal to $P$. $R$ is to be considered the total amount of reward that is to be split among all the producers that found the correct ledger update $R = f_{prod}X + v$ where $f_{prod}$ is the fraction of the injected tokens that are given to users found in the combined $\mathcal{L}(prod)$. While $(1-f_{prod})X$ is the value that is distributed to other nodes that have performed work.
\item Producer $p$ can then create the candidate ledger state update for this cycle. This includes the reward allocations for producers according to their contributions. This ledger state update $LSU$ can be defined as:

\begin{center}
$\mathbf{LSU = L~||~d~||~L_{CE}}$
\end{center}


$p$ then computes its vote (or \textit{producer vote}):
\begin{center}
\fbox{$V = \mathcal{H}(LSU)~||~\#(\mathcal{L}(vote))~||~Id$}
\end{center}


\item $p$ then forwards their $V$ to the other producers and collects the producer votes $V$ issued by its peers.

\end{enumerate}


During the voting phase, the producer $p$ collects the producer votes $V$ broadcast by its peers. At the end of the voting phase , the producer $p$ holds $U$ producer votes $V$ in its cache. This will be equal to or less than the number of producers who formed the correct update.

\end{comment} 

