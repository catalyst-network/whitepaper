Bloom filters are data structures that allow proof of membership of a set. They work is such a way that they can never provide a false negative i.e. showing that an element is in fact in the bloom filter as false. They can however show false positives meaning that an element that is not in the bloom filter can in fact come back true. Bloom filters are simple byte arrays of a specified length. Upon initialisation all bits within the byte array are set to 0. For each element to be added to the bloom filter it is hashed a defined number of times and the coresponding bit for the hash is flipped to a 1. For example for a small bit array \verb'0bx0000' and element \verb'Hello' is hashed to give the digest \verb'04' then the $4^{th}$ bit would be flipped so the bloom filter would become \verb'0bx1000'. This works on a modulo point, so if the digest was \verb'05' then the first bit would be flipped giving the bloom filter \verb'0bx0001'. For each element added to the bloom filter multiple hashes are created and added to the bloom filter, for example if 3 hashing functions are used 3 bits in total will be flipped in the bloom filter and these 3 flipped bits will represent the element. \\

The reason for choosing a bloom filter over directly transferring the lists is for size considerations. Distributing a list containing 100 or a 1000 elements will be extremely cumbersome due to the size. While a bloom filter for 1000 elements would be approximately 1.4kBytes in size. While if it is considered the every PID is 32Bytes long each producer would potentially be required to distribute lists that are 32KBytes in size if the raw lists are distributed in the consensus mechanism. 